
/*
 *  This file is part of pmcjs.
 *  Copyright (C) 2006 A.Higuchi. All rights reserved.
 *  See COPYRIGHT.txt for details.
 */

#include "pmcjs.h"
#include "pmcjs_impl.h"
#include "pmobject.h"
#include "pmconv.h"
#include "polist.h"

static const char pmc_modstr_util[] = 
"package JavaScript::Util;\n"
"\n"
"sub hv_fetch {\n"
"  my $hv = shift;\n"
"  my $key = shift;\n"
"  return $hv->{$key};\n"
"}\n"
"\n"
"sub hv_store {\n"
"  my $hv = shift;\n"
"  my $key = shift;\n"
"  my $val = shift;\n"
"  $hv->{$key} = $val;\n"
"}\n"
"\n"
"sub hv_delete {\n"
"  my $hv = shift;\n"
"  my $key = shift;\n"
"  delete $hv->{$key};\n"
"}\n"
"\n"
"sub av_fetch {\n"
"  my $av = shift;\n"
"  my $key = shift;\n"
"  return $av->[$key];\n"
"}\n"
"\n"
"sub av_store {\n"
"  my $av = shift;\n"
"  my $key = shift;\n"
"  my $val = shift;\n"
"  $av->[$key] = $val;\n"
"}\n"
"\n"
"sub av_delete {\n"
"  my $av = shift;\n"
"  my $key = shift;\n"
"  delete $av->[$key]\n"
"}\n"
"\n"
"sub av_fetchsize {\n"
"  my $av = shift;\n"
"  return scalar(@$av)\n"
"}\n"
"\n"
"sub sv_setsv {\n"
"  @_[0] = @_[1];\n"
"}\n"
"\n"
"sub eval_str {\n"
"  use utf8;\n"
"  package main;\n"
"  my $r = eval $_[0];\n"
"  return $r, $@;\n"
"}\n"
"\n"
"sub child_error {\n"
"  if (scalar(@_) != 0) { $? = @_[0]; }\n"
"  return $?;\n"
"}\n"
"\n"
"sub tie_scalar {\n"
"  my $svr = \\@_[0];\n"
"  shift;\n"
"  my $classname = shift;\n"
"  tie $$svr, $classname, @_;\n"
"}\n"
"\n"
"sub tie_hash {\n"
"  my $hr = shift;\n"
"  my $classname = shift;\n"
"  return tie %$hr, $classname, @_;\n"
"}\n"
"\n"
"sub tie_array {\n"
"  my $ar = shift;\n"
"  my $classname = shift;\n"
"  return tie @$ar, $classname, @_;\n"
"}\n"
"\n"
"sub untie_scalar {\n"
"  my $svr = \\@_[0];\n"
"  shift;\n"
"  untie $$svr;\n"
"}\n"
"\n"
"sub untie_hash {\n"
"  my $hr = shift;\n"
"  untie %$hr;\n"
"}\n"
"\n"
"sub untie_array {\n"
"  my $ar = shift;\n"
"  untie @$ar;\n"
"}\n"
"\n"
"sub new_tied_hash {\n"
"  my $classname = shift;\n"
"  my %hv = ();\n"
"  tie %hv, $classname, @_;\n"
"  return \\%hv\n"
"}\n"
"\n"
"sub new_tied_array {\n"
"  my $classname = shift;\n"
"  my @av = ();\n"
"  tie @av, $classname, @_;\n"
"  return \\@av\n"
"}\n"
"\n"
;

static const char pmc_modstr_objwrap[] = 
"package JavaScript::HTTie;\n"
"\n"
"use Tie::Hash;\n"
"@ISA = ('Tie::Hash');\n"
"\n"
"sub TIEHASH {\n"
"  my $classname = shift;\n"
"  my $inner = shift;\n"
"  my $obj = bless \\$inner, $classname;\n"
"  return $obj;\n"
"}\n"
"\n"
"sub FETCH {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $inner = $$obj;\n"
"  return $inner->GetProperty($key);\n"
"}\n"
"\n"
"sub STORE {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $val = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->SetProperty($key, $val);\n"
"}\n"
"\n"
"sub DELETE {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->DelProperty($key);\n"
"}\n"
"\n"
"sub FIRSTKEY {\n"
"  my $obj = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->ResetIterator();\n"
"  return $inner->Iterate();\n"
"}\n"
"\n"
"sub NEXTKEY {\n"
"  my $obj = shift;\n"
"  my $lastkey = shift;\n"
"  my $inner = $$obj;\n"
"  return $inner->Iterate($lastkey);\n"
"}\n"
"\n"
"sub EXISTS {\n"
"  return 1;\n"
"}\n"
"\n"
"\n"
"package JavaScript::ATie;\n"
"\n"
"use Tie::Array;\n"
"@ISA = ('Tie::Array');\n"
"\n"
"sub TIEARRAY {\n"
"  my $classname = shift;\n"
"  my $inner = shift;\n"
"  my $obj = bless \\$inner, $classname;\n"
"  return $obj;\n"
"}\n"
"\n"
"sub FETCH {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $inner = $$obj;\n"
"  return $inner->GetElement($key);\n"
"}\n"
"\n"
"sub STORE {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $val = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->SetElement($key, $val);\n"
"}\n"
"\n"
"sub DELETE {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->DelElement($key);\n"
"}\n"
"\n"
"sub FETCHSIZE {\n"
"  my $obj = shift;\n"
"  my $inner = $$obj;\n"
"  return $inner->GetLength();\n"
"}\n"
"\n"
"sub STORESIZE {\n"
"  my $obj = shift;\n"
"  my $len = shift;\n"
"  my $inner = $$obj;\n"
"  $inner->SetLength($len);\n"
"}\n"
"\n"
"sub EXISTS {\n"
"  my $obj = shift;\n"
"  my $key = shift;\n"
"  my $inner = $$obj;\n"
"  return $key >= 0 && $key < $inner->GetLength();\n"
"}\n"
"\n"
"package JavaScript::HTWrap;\n"
"\n"
"sub new {\n"
"  my $class = shift;\n"
"  my $inner = shift;\n"
"  my %mh = ();\n"
"  tie %mh, 'JavaScript::HTTie', $inner;\n"
"  my $instance = \\%mh;\n"
"  bless $instance, $class;\n"
"  return $instance;\n"
"}\n"
"\n"
"sub GetProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  return $$t->GetProperty(@_);\n"
"}\n"
"\n"
"sub SetProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  return $$t->SetProperty(@_);\n"
"}\n"
"sub DelProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  return $$t->DelProperty(@_);\n"
"}\n"
"\n"
"sub Invoke {\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  return $$t->Invoke(@_);\n"
"}\n"
"\n"
"sub InvokeSelf {\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  return $$t->InvokeSelf(@_);\n"
"}\n"
"\n"
"sub AUTOLOAD {\n"
"  my $al = our $AUTOLOAD;\n"
"  return if $al =~ /::DESTROY$/;\n"
"  my $instance = shift;\n"
"  my $t = tied %$instance;\n"
"  my $r = $$t->Invoke($al, @_);\n"
"  return $r;\n"
"}\n"
"\n"
"package JavaScript::AWrap;\n"
"\n"
"sub new {\n"
"  my $class = shift;\n"
"  my $inner = shift;\n"
"  my @ma = ();\n"
"  tie @ma, 'JavaScript::ATie', $inner;\n"
"  my $instance = \\@ma;\n"
// "  bless $instance, $class;\n" // ARGUABLE: bless?
"  return $instance;\n"
"}\n"
"\n"
"sub GetProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  return $$t->GetProperty(@_);\n"
"}\n"
"\n"
"sub SetProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  return $$t->SetProperty(@_);\n"
"}\n"
"sub DelProperty {\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  return $$t->DelProperty(@_);\n"
"}\n"
"\n"
"sub Invoke {\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  return $$t->Invoke(@_);\n"
"}\n"
"\n"
"sub InvokeSelf {\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  return $$t->InvokeSelf(@_);\n"
"}\n"
"\n"
"sub AUTOLOAD {\n"
"  my $al = our $AUTOLOAD;\n"
"  return if $al =~ /::DESTROY$/;\n"
"  my $instance = shift;\n"
"  my $t = tied @$instance;\n"
"  my $r = $$t->Invoke($al, @_);\n"
"  return $r;\n"
"}\n"
"\n"
"package JavaScript::CWrap;\n"
"\n"
"sub new {\n"
"  my $class = shift;\n"
"  my $inner = shift;\n"
"  my $isul = shift;\n"
"  my $instance = sub { \n" /* see pmc_sv_extract_jsfunc_from_cv */
"    my $z = $_[0];\n"
"    if (ref($z) eq 'CODE' && $z == \\&new) {\n"
"      return $inner;\n"
"    }\n"
"    if ($isul) {\n"
"      $_ = JavaScript->Call($inner, $_);\n"
"      return $_;\n"
"    } else {\n"
"      return JavaScript->Call($inner, @_);\n"
"    }\n"
"  };\n"
// "  bless $instance, $class;\n" // ARGUABLE: bless?
"  return $instance;\n"
"}\n"
"\n"
"sub GetProperty {\n"
"  my $instance = shift;\n"
"  return $instance->(\\&new)->GetProperty(@_);\n"
"}\n"
"\n"
"sub SetProperty {\n"
"  my $instance = shift;\n"
"  return $instance->(\\&new)->SetProperty(@_);\n"
"}\n"
"\n"
"sub DelProperty {\n"
"  my $instance = shift;\n"
"  return $instance->(\\&new)->DelProperty(@_);\n"
"}\n"
"sub Invoke {\n"
"  my $instance = shift;\n"
"  return $instance->(\\&new)->Invoke(@_);\n"
"}\n"
"\n"
"sub InvokeSelf {\n"
"  my $instance = shift;\n"
"  return $instance->(\\&new)->InvokeSelf(@_);\n"
"}\n"
"\n"
"sub AUTOLOAD {\n"
"  my $al = our $AUTOLOAD;\n"
"  return if $al =~ /::DESTROY$/;\n"
"  my $instance = shift;\n"
"  my $r = $instance->(\\&new)->Invoke($al, @_);\n"
"  return $r;\n"
"}\n"
"\n"
"package JavaScript;\n"
"\n"
"sub AUTOLOAD {\n"
"  my $al = our $AUTOLOAD;\n"
"  return if $al =~ /::DESTROY$/;\n"
"  my $instance = shift;\n"
"  my $r = $instance->Invoke($al, @_);\n"
"  return $r;\n"
"}\n"
"\n"
"sub CLONE {\n"
"  die 'you can not clone JavaScript context';\n"
"}\n"
"\n"
"sub STORABLE_freeze {\n" /* forbid serialization and deep cloning */
"  return 0;\n"
"}\n"
"\n"
"sub STORABLE_thaw {\n"
"}\n"
"\n"
;

static const char pmc_modstr_core[] = 
"package JavaScript::CORE;\n"
"\n"
"sub chomp { CORE::chomp($_[0]); }\n"
"sub chop { CORE::chop($_[0]); }\n"
"sub chr { return CORE::chr($_[0]); }\n"
"sub crypt { return CORE::crypt($_[0], $_[1]); }\n"
"sub hex { return CORE::hex($_[0]); }\n"
"sub index {\n"
"  if (scalar(@_) < 3) { return CORE::index($_[0], $_[1]); }\n"
"  return CORE::index($_[0], $_[1], $_[2]);\n"
"}\n"
"sub lc { return CORE::lc($_[0]); }\n"
"sub lcfirst { return CORE::lcfirst($_[0]); }\n"
"sub length { return CORE::length($_[0]); }\n"
"sub oct { return CORE::oct($_[0]); }\n"
"sub ord { return CORE::ord($_[0]); }\n"
"sub reverse {\n"
"  my $x = $_[0];\n"
"  my $xr = ref($x);\n"
"  if ($xr eq \'HASH\' || $xr eq \'JavaScript::HWrap\') {\n"
"    my %r = CORE::reverse(%$x);\n"
"    return \\%r;\n"
"  } elsif ($xr eq \'ARRAY\' || $xr eq \'JavaScript::AWrap\') {\n"
"    my @r = CORE::reverse(@$x);\n"
"    return \\@r;\n"
"  }\n"
"  return CORE::reverse($_[0]);\n"
"}\n"
"sub rindex {\n"
"  if (scalar(@_) < 3) { return CORE::rindex($_[0], $_[1]); }\n"
"  return CORE::rindex($_[0], $_[1], $_[2]);\n"
"}\n"
"sub sprintf { return CORE::sprintf(CORE::shift, @_); }\n"
"sub substr {\n"
"  my $ac = scalar(@_);\n"
"  if ($ac >= 4) {\n"
"    return CORE::substr($_[0], $_[1], $_[2], $_[3]); }\n"
"  if ($ac == 3) { return CORE::substr($_[0], $_[1], $_[2]); }\n"
"  return CORE::substr($_[0], $_[1]);\n"
"}\n"
"sub uc { return CORE::uc($_[0]); }\n"
"sub ucfirst { return CORE::ucfirst($_[0]); }\n"
"sub pop { return CORE::pop(@{$_[0]}); }\n"
"sub push { return CORE::push(@{CORE::shift()}, @_); }\n"
"sub shift { return CORE::shift(@{$_[0]}); }\n"
"sub splice {\n"
"  my @r;\n"
"  my $ac = scalar(@_);\n"
"  if ($ac >= 4) {\n"
"     @r = CORE::splice(@{CORE::shift()}, CORE::shift, CORE::shift, @_);\n"
"  } elsif ($ac == 3) {\n"
"     @r = CORE::splice(@{$_[0]}, $_[1], $_[2]);\n"
"  } elsif ($ac == 2) {\n"
"     @r = CORE::splice(@{$_[0]}, $_[1]);\n"
"  } else {\n"
"     @r = CORE::splice(@{$_[0]});\n"
"  }\n"
"  return \\@r;\n"
"}\n"
"sub unshift { return CORE::unshift(@{CORE::shift()}, @_); }\n"
"sub grep {\n"
"  my ($x, $y) = @_;\n"
"  my $s = sub { return $x->($_); };\n"
"  my @r = CORE::grep(&$s, @$y);\n"
"  return \\@r;\n"
"}\n"
"sub join { return CORE::join($_[0], @{$_[1]}); }\n"
"sub map {\n"
"  my ($x, $y) = @_;\n"
"  my $s = sub { return $x->($_); };\n"
"  my @r = CORE::map(&$s, @$y);\n"
"  return \\@r;\n"
"}\n"
"sub sort {\n"
"  my @z;\n"
"  if (scalar(@_) == 1) { @z = CORE::sort @{$_[0]}; }\n"
"  else {\n"
"    my ($x, $y) = @_;\n"
"    my $s = sub ($$) { return $x->($_[0], $_[1]); };\n"
"    @z = CORE::sort $s @$y;\n"
"  }\n"
"  return \\@z;\n"
"}\n"
"sub pack { return CORE::pack($_[0], @{$_[1]}); }\n"
"sub unpack { my @r = CORE::unpack($_[0], $_[1]); return \\@r; }\n"
"sub keys { my @r = CORE::keys(%{$_[0]}); return \\@r; }\n"
"sub values { my @r = CORE::values(%{$_[0]}); return \\@r; }\n"
"sub abs { return CORE::abs($_[0]); }\n"
"sub atan2 { return CORE::atan2($_[0], $_[1]); }\n"
"sub cos { return CORE::cos($_[0]); }\n"
"sub exp { return CORE::exp($_[0]); }\n"
"sub int { return CORE::int($_[0]); }\n"
"sub log { return CORE::log($_[0]); }\n"
"sub rand { return CORE::rand($_[0]); }\n"
"sub sin { return CORE::sin($_[0]); }\n"
"sub sqrt { return CORE::sqrt($_[0]); }\n"
"sub srand {\n"
"  if (scalar(@_) >= 1) { CORE::srand($_[0]); }\n"
"  else { CORE::srand(); }\n"
"}\n"
"sub fork { return CORE::fork(); }\n"
"sub alarm { return CORE::alarm($_[0]); }\n"
"sub exec {\n"
"  if (ref($_[0])) { return CORE::exec(@{$_[0]}); }\n"
"  else { return CORE::exec(@_); }\n"
"}\n"
"sub system {\n"
"  if (ref($_[0])) { return CORE::system(@{$_[0]}); }\n"
"  else { return CORE::system(@_); }\n"
"}\n"
"sub wait { return CORE::wait(); }\n"
"sub waitpid { return CORE::waitpid($_[0], $_[1]); }\n"
"sub exit { return CORE::exit(scalar(@_) == 0 ? 0 : $_[0]); }\n"
;

const char *
pmc_get_pkg_javascript_util_str()
{
  return pmc_modstr_util;
}

const char *
pmc_get_pkg_javascript_objwrap_str()
{
  return pmc_modstr_objwrap;
}

const char *
pmc_get_pkg_javascript_core_str()
{
  return pmc_modstr_core;
}

